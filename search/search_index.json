{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Eywa - Framework for Conversational Agents Eywa is an open source framework for building and deploying conversational agents (aka chatbots). Features: Requires only few samples for training Instant retraining Uses word embeddings + heuristics instead of deep learning (better debuggability and interpretability) Quickstart Classifier from eywa.nlu import Classifier x_hotel = ['book a hotel', 'need a nice place to stay', 'any motels near by'] x_weather = ['what is the weather like', 'is it hot outside'] clf = Classifier() clf.fit(x_hotel, 'hotel') clf.fit(x_weather, 'weather') print(clf.predict('will it rain today')) # >>> 'weather' print(clf.predict('find a place to stay')) # >>> 'hotel' Entity extractor from eywa.nlu import EntityExtractor x = ['what is the weather in tokyo', 'what is the weather', 'what is the weather like in kochi'] y = [{'intent': 'weather', 'place': 'tokyo'}, {'intent': 'weather', 'place': 'here'}, {'intent': 'weather', 'place': 'kochi'}] ex = EntityExtractor() ex.fit(x, y) x_test = 'what is the weather in london like' print(ex.predict(x_test)) Pattern from eywa.nlu import Pattern p = Pattern('[fruit: apple, banana] is my favourite fruit') # create variable [fruit] with sample values {apple, babana} p('i like grapes') # >> {'fruit' : 'grapes'} Requirements Python 3.6 or higher Eywa requires Tensorflow 2.0 and should be installed manually by the user (is not installed automatically as a dependency) Installation Via pip: pip install eywa Install from source: git clone https://www.github.com/farizrahman4u/eywa.git cd eywa python setup.py install","title":"Eywa - Framework for Conversational Agents"},{"location":"#eywa-framework-for-conversational-agents","text":"Eywa is an open source framework for building and deploying conversational agents (aka chatbots).","title":"Eywa - Framework for Conversational Agents"},{"location":"#features","text":"Requires only few samples for training Instant retraining Uses word embeddings + heuristics instead of deep learning (better debuggability and interpretability)","title":"Features:"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#classifier","text":"from eywa.nlu import Classifier x_hotel = ['book a hotel', 'need a nice place to stay', 'any motels near by'] x_weather = ['what is the weather like', 'is it hot outside'] clf = Classifier() clf.fit(x_hotel, 'hotel') clf.fit(x_weather, 'weather') print(clf.predict('will it rain today')) # >>> 'weather' print(clf.predict('find a place to stay')) # >>> 'hotel'","title":"Classifier"},{"location":"#entity-extractor","text":"from eywa.nlu import EntityExtractor x = ['what is the weather in tokyo', 'what is the weather', 'what is the weather like in kochi'] y = [{'intent': 'weather', 'place': 'tokyo'}, {'intent': 'weather', 'place': 'here'}, {'intent': 'weather', 'place': 'kochi'}] ex = EntityExtractor() ex.fit(x, y) x_test = 'what is the weather in london like' print(ex.predict(x_test))","title":"Entity extractor"},{"location":"#pattern","text":"from eywa.nlu import Pattern p = Pattern('[fruit: apple, banana] is my favourite fruit') # create variable [fruit] with sample values {apple, babana} p('i like grapes') # >> {'fruit' : 'grapes'}","title":"Pattern"},{"location":"#requirements","text":"Python 3.6 or higher Eywa requires Tensorflow 2.0 and should be installed manually by the user (is not installed automatically as a dependency)","title":"Requirements"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-pip","text":"pip install eywa","title":"Via pip:"},{"location":"#install-from-source","text":"git clone https://www.github.com/farizrahman4u/eywa.git cd eywa python setup.py install","title":"Install from source:"},{"location":"examples/agent/","text":"The bot will welcome you with a greeting message once it is running. current conversatonal capablities. greetings - Hi , hello etc cab booking - book a cab to weather - what is the weather in date - what is the date today Sample conversation Agent : Hello what would you like me to do ? you : what is the weather in New York Agent : The weather in New_York is warm you : book a cab to NYC Agent : Booking a cab for NYC you : what is the date today Agent : Today is 2019-01-17 import random import datetime from eywa.nlu import Classifier from eywa.nlu import EntityExtractor # Classifier, predicts the class of user input. CONV_SAMPLES = { 'greetings' : ['Hi', 'hello', 'How are you', 'hey there', 'hey'], 'taxi' : ['book a cab', 'need a ride', 'find me a cab'], 'weather' : ['what is the weather in tokyo', 'weather germany', 'what is the weather like in kochi'], 'datetime' : ['what day is today', 'todays date', 'what time is it now', 'time now', 'what is the time']} CLF = Classifier() for key in CONV_SAMPLES: CLF.fit(CONV_SAMPLES[key], key) # Entitiy Extractor, gets the required entities from the input. X_WEATHER = ['what is the weather in tokyo', 'weather germany', 'what is the weather like in kochi'] Y_WEATHER = [{'intent': 'weather', 'place': 'tokyo'}, {'intent': 'weather', 'place': 'germany'}, {'intent': 'weather', 'place': 'kochi'}] EX_WEATHER = EntityExtractor() EX_WEATHER.fit(X_WEATHER, Y_WEATHER) X_TAXI = ['book a cab to kochi ', 'need a ride to delhi', 'find me a cab for manhattan', 'call a taxi to calicut'] Y_TAXI = [{'service': 'cab', 'destination': 'kochi'}, {'service': 'ride', 'destination' : 'delhi'}, {'service': 'cab', 'destination' : 'manhattan'}, {'service': 'taxi', 'destination' : 'calicut'}] EX_TAXI = EntityExtractor() EX_TAXI.fit(X_TAXI, Y_TAXI) X_GREETING = ['Hii', 'helllo', 'Howdy', 'hey there', 'hey', 'Hi'] Y_GREETING = [{'greet': 'Hii'}, {'greet': 'helllo'}, {'greet': 'Howdy'}, {'greet': 'hey'}, {'greet': 'hey'}, {'greet': 'Hi'}] EX_GREETING = EntityExtractor() EX_GREETING.fit(X_GREETING, Y_GREETING) X_DATETIME = ['what day is today', 'date today', 'what time is it now', 'time now'] Y_DATETIME = [{'intent' : 'day', 'target': 'today'}, {'intent' : 'date', 'target': 'today'}, {'intent' : 'time', 'target': 'now'}, {'intent' : 'time', 'target': 'now'}] EX_DATETIME = EntityExtractor() EX_DATETIME.fit(X_DATETIME, Y_DATETIME) _EXTRACTORS = {'taxi':EX_TAXI, 'weather':EX_WEATHER, 'greetings':EX_GREETING, 'datetime':EX_DATETIME} # Response logic. def get_response(u_query): ''' Accepts user query and returns a response based on the class of query ''' responses = {} rd_i = random.randint(0, 2) # Predict the class of the query. q_class = CLF.predict(u_query) # Run entity extractor of the predicted class on the query. q_entities = _EXTRACTORS[q_class].predict(u_query) # Get response based on the class of the query. if q_class == 'weather': responses['weather'] = 'The '+q_entities['intent']+' in '+q_entities['place']+ ' is warm' def get_weather(): # Weather api call. pass if q_class == 'taxi': responses['taxi'] = 'Booking a '+q_entities['service']+ ' for '+q_entities['destination'] def get_taxi(): # Uber/Ola api. pass if q_class == 'datetime': responses['datetime'] = 'Today is '+str(datetime.datetime.today()).split(' ')[0] def get_dateime(): # Calender api. pass if q_class == 'greetings': responses['greetings'] = ['Hey', 'Hi there', 'Hello'][rd_i]+['\\n what would you like me to do ?', '', '\\n what would you like me to do ?'][rd_i] return 'Agent : '+responses[q_class] # Conversation loop. if __name__ == '__main__': # Greeting user on startup. print(get_response('Hi')) while True: UQUERY = input('you : ') if UQUERY == 'bye': break RESPONSE = get_response(UQUERY) print(RESPONSE)","title":"Agent"},{"location":"models/Classifer/","text":"[source] Classifier eywa.nlu.classifier.Classifier() Predicts the class of user input. fit fit(X, Y) Trains the model on given data. Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target labels. str (or list thereof). If list , number of items in Y should be either 1 or equal to number of utterances in X. Example Train a Classifier to classify a given utterance to 2 classes: \"greeting\" and \"bye\": Method 1 - fit on individual utterances: clf = Classifier() clf.fit('hi', 'greeting') clf.fit('good bye', 'bye') clf.fit('hello', 'greeting') clf.fit('see you later', 'bye') Method 2 - fit on list of utterances: clf = Classifier() greetings = ['hi', 'hello', 'hey'] bye = ['bye', 'good bye', 'see you later'] clf.fit(greetings, 'greeting') clf.fit(bye, 'bye') Method 3 - fit on list of utterances and labels: clf = Classifier() input_data = ['hi', 'good bye', 'hello', 'hey', 'see you later'] target_labels = ['greeting', 'bye', 'greeting', 'greeting', 'bye'] clf.fit(input_data, target_labels) predict predict(x, return_scores=False) Predicts labels for given input utterance(s) Arguments x: Input utterance(s). It could be: - str (or list / tuple thereof) - Document instance (or list / tuple thereof) return_scores : bool . Default False . If True , returns confidence for each class per utterance. Else, returns label for class with highest confidence per utterance. Returns if return_scores is True : if x is a single utterance: Returns a list of tuple s of the form (label, confidence) for each class, sorted by decreasing order of confidence. if x is a list / tuple of utterances: Returns a list of results with 1 result per utterance. Each result will be a list of tuple s of the form (label, confidence) for each class, sorted by decreasing order of confidence. if return_scores is False : if x is a single utterance: Returns the predicted label as str . if x is a list / tuple of utterances: Returns the predicted labels for utterances as list of str . evaluate evaluate(X=None, Y=None) Evaluates the Classfier on given data. Either both X and Y arguments should be provided or both of them should be left unspecified ( None ). If left unspecified, the cumilative data used to train the Classifier will be used for evaluation . Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target labels. str (or list thereof). If list, number of items in Y should be either 1 or equal to number of utterances in X. Returns tuple of error( float ) and accuracy( float ) serialize serialize() Serializes the Classifier object to a json friendly config. Returns dict deserialize deserialize(config) Deserializes a Classifer config to a Classifier instance. Arguments config: dict . Classifier config (generated by Classifier.serialize ). Returns Classifier instance set_weights set_weights(weights) Sets weights of the Classifier to given values. Arguments weights: list of numpy arrays get_weights get_weights() Returns weights of the Classifier . Returns list of numpy arrays","title":"Classifier"},{"location":"models/Classifer/#classifier","text":"eywa.nlu.classifier.Classifier() Predicts the class of user input.","title":"Classifier"},{"location":"models/Classifer/#fit","text":"fit(X, Y) Trains the model on given data. Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target labels. str (or list thereof). If list , number of items in Y should be either 1 or equal to number of utterances in X. Example Train a Classifier to classify a given utterance to 2 classes: \"greeting\" and \"bye\": Method 1 - fit on individual utterances: clf = Classifier() clf.fit('hi', 'greeting') clf.fit('good bye', 'bye') clf.fit('hello', 'greeting') clf.fit('see you later', 'bye') Method 2 - fit on list of utterances: clf = Classifier() greetings = ['hi', 'hello', 'hey'] bye = ['bye', 'good bye', 'see you later'] clf.fit(greetings, 'greeting') clf.fit(bye, 'bye') Method 3 - fit on list of utterances and labels: clf = Classifier() input_data = ['hi', 'good bye', 'hello', 'hey', 'see you later'] target_labels = ['greeting', 'bye', 'greeting', 'greeting', 'bye'] clf.fit(input_data, target_labels)","title":"fit"},{"location":"models/Classifer/#predict","text":"predict(x, return_scores=False) Predicts labels for given input utterance(s) Arguments x: Input utterance(s). It could be: - str (or list / tuple thereof) - Document instance (or list / tuple thereof) return_scores : bool . Default False . If True , returns confidence for each class per utterance. Else, returns label for class with highest confidence per utterance. Returns if return_scores is True : if x is a single utterance: Returns a list of tuple s of the form (label, confidence) for each class, sorted by decreasing order of confidence. if x is a list / tuple of utterances: Returns a list of results with 1 result per utterance. Each result will be a list of tuple s of the form (label, confidence) for each class, sorted by decreasing order of confidence. if return_scores is False : if x is a single utterance: Returns the predicted label as str . if x is a list / tuple of utterances: Returns the predicted labels for utterances as list of str .","title":"predict"},{"location":"models/Classifer/#evaluate","text":"evaluate(X=None, Y=None) Evaluates the Classfier on given data. Either both X and Y arguments should be provided or both of them should be left unspecified ( None ). If left unspecified, the cumilative data used to train the Classifier will be used for evaluation . Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target labels. str (or list thereof). If list, number of items in Y should be either 1 or equal to number of utterances in X. Returns tuple of error( float ) and accuracy( float )","title":"evaluate"},{"location":"models/Classifer/#serialize","text":"serialize() Serializes the Classifier object to a json friendly config. Returns dict","title":"serialize"},{"location":"models/Classifer/#deserialize","text":"deserialize(config) Deserializes a Classifer config to a Classifier instance. Arguments config: dict . Classifier config (generated by Classifier.serialize ). Returns Classifier instance","title":"deserialize"},{"location":"models/Classifer/#set_weights","text":"set_weights(weights) Sets weights of the Classifier to given values. Arguments weights: list of numpy arrays","title":"set_weights"},{"location":"models/Classifer/#get_weights","text":"get_weights() Returns weights of the Classifier . Returns list of numpy arrays","title":"get_weights"},{"location":"models/EntityExtractor/","text":"[source] EntityExtractor eywa.nlu.entity_extractor.EntityExtractor() Gets the required entities from the input. fit fit(X, Y) Trains the model on given data. Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target values. dict mapping from from entity name ( str ) to entity value ( str )(or list thereof). The entity names should be same throughout all dict elements and number of dict elements should be same as the number of elements of X. Example Train an EntityExtractor to extract entities \"intent\" and \"place\" from utterances labels \"intent\" and \"place\": x = ['who was the first president of USA', 'which party got elected last time'] y = [{'intent': 'politics', 'place': 'USA'}, {'intent': 'politics','place': 'here'}] ex = EntityExtractor() ex.fit(x, y) predict predict(x, keys=None, return_scores=False) Extracts entities for given input utterance(s). Arguments x: Input utterance(s). It could be: - str (or list / tuple thereof) - Document instance (or list / tuple thereof) return_scores : bool . Default False . If True , Returns a dict (or list thereof if x is a list) mapping entity names to a list of tuples, where each tuple consists of a possible entity value ( str ) and a confidence score ( float ). Else, returns entity name for entity value with highest confidence per utterance. keys :list of str. entities to be extracted. If not specified, all entities will be extracted. Returns if return_scores is True : if x is a single utterance: Returns a list of dict s of the form (entity name, confidence) for each class, sorted by decreasing order of confidence. if x is a list / tuple of utterances: Returns a list of results with 1 result per utterance. Each result will be a list of dict s of the form (entity name, confidence) for each class, sorted by decreasing order of confidence. if return_scores is False : if x is a single utterance: Returns the predicted label as dict . if x is a list / tuple of utterances: Returns the predicted labels for utterances as list of dict s. evaluate evaluate(X=None, Y=None) Evaluates the EntityExtractor on given data. Either both X and Y arguments should be provided or both of them should be left unspecified ( None ). If left unspecified, the cumilative data used to train the EntityExtractor will be used for evaluation . Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target values. dict mapping from from entity name ( str ) to entity value ( str )(or list thereof). The entity names should be same throughout all dict elements and number of dict elements should be same as the number of elements of X. Returns tuple of error( float ) and accuracy( float ) serialize serialize() Serializes the EntityExtractor object to a json friendly config. Returns dict deserialize deserialize(config) Deserializes a EntityExtractor config to a EntityExtractor instance. Arguments config: dict . EntityExtractor config (generated by EntityExtractor.serialize ). Returns EntityExtractor instance set_weights set_weights(weights) Sets weights of the EntityExtractor to given values. Arguments weights: list of numpy arrays get_weights get_weights() Returns weights of the EntityExtractor . Returns list of numpy arrays","title":"EntityExtractor"},{"location":"models/EntityExtractor/#entityextractor","text":"eywa.nlu.entity_extractor.EntityExtractor() Gets the required entities from the input.","title":"EntityExtractor"},{"location":"models/EntityExtractor/#fit","text":"fit(X, Y) Trains the model on given data. Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target values. dict mapping from from entity name ( str ) to entity value ( str )(or list thereof). The entity names should be same throughout all dict elements and number of dict elements should be same as the number of elements of X. Example Train an EntityExtractor to extract entities \"intent\" and \"place\" from utterances labels \"intent\" and \"place\": x = ['who was the first president of USA', 'which party got elected last time'] y = [{'intent': 'politics', 'place': 'USA'}, {'intent': 'politics','place': 'here'}] ex = EntityExtractor() ex.fit(x, y)","title":"fit"},{"location":"models/EntityExtractor/#predict","text":"predict(x, keys=None, return_scores=False) Extracts entities for given input utterance(s). Arguments x: Input utterance(s). It could be: - str (or list / tuple thereof) - Document instance (or list / tuple thereof) return_scores : bool . Default False . If True , Returns a dict (or list thereof if x is a list) mapping entity names to a list of tuples, where each tuple consists of a possible entity value ( str ) and a confidence score ( float ). Else, returns entity name for entity value with highest confidence per utterance. keys :list of str. entities to be extracted. If not specified, all entities will be extracted. Returns if return_scores is True : if x is a single utterance: Returns a list of dict s of the form (entity name, confidence) for each class, sorted by decreasing order of confidence. if x is a list / tuple of utterances: Returns a list of results with 1 result per utterance. Each result will be a list of dict s of the form (entity name, confidence) for each class, sorted by decreasing order of confidence. if return_scores is False : if x is a single utterance: Returns the predicted label as dict . if x is a list / tuple of utterances: Returns the predicted labels for utterances as list of dict s.","title":"predict"},{"location":"models/EntityExtractor/#evaluate","text":"evaluate(X=None, Y=None) Evaluates the EntityExtractor on given data. Either both X and Y arguments should be provided or both of them should be left unspecified ( None ). If left unspecified, the cumilative data used to train the EntityExtractor will be used for evaluation . Arguments X: Input utterance(s). It could be: - str (or list thereof) - Document instance (or list thereof) Y: Target values. dict mapping from from entity name ( str ) to entity value ( str )(or list thereof). The entity names should be same throughout all dict elements and number of dict elements should be same as the number of elements of X. Returns tuple of error( float ) and accuracy( float )","title":"evaluate"},{"location":"models/EntityExtractor/#serialize","text":"serialize() Serializes the EntityExtractor object to a json friendly config. Returns dict","title":"serialize"},{"location":"models/EntityExtractor/#deserialize","text":"deserialize(config) Deserializes a EntityExtractor config to a EntityExtractor instance. Arguments config: dict . EntityExtractor config (generated by EntityExtractor.serialize ). Returns EntityExtractor instance","title":"deserialize"},{"location":"models/EntityExtractor/#set_weights","text":"set_weights(weights) Sets weights of the EntityExtractor to given values. Arguments weights: list of numpy arrays","title":"set_weights"},{"location":"models/EntityExtractor/#get_weights","text":"get_weights() Returns weights of the EntityExtractor . Returns list of numpy arrays","title":"get_weights"}]}